## Git Repository

- 하나의 큰 거대한 상자(컨테이너)
- 프로젝트의 모든 파트를 적재
- 모든 변경 사항을 추적
- Git 저장소를 생성하면
    - 특별한 공간이 생깁니다.
    - 이 공간에 모든 파일의 버전을 저장할 수 있습니다
    - 또한, 다른 사용자와 협업하거나, 저장소를 공유할 수 있습니다
- 변경, 수정, 새 기능 추가를 투명하게 진행 할 수 있습니다.

### Git Repository Fork

- 하나의 큰 거대한 상자(컨테이너)를 다른 계정(또는 네임스페이스)으로 복사
- Git에 있는 명령어가 아님

### Git Repository Clone

- Git clone은 저장소를 로컬 시스템에 복제하는 방법
- 여기에는 지금까지 모든 Git Repository의 히스토리가 포함

```
$ git clone https://github.com/username/repository.git
```

### Clone VS Fork

**Clone**

Git Repo AAA → Clone → User

Fork

Git Repo BBB → Fork → Git Repo Forked BBB → Clone → User

### Git init

- 말 그대로 초기화. 새 로컬 git 저장소를 만드는데 사용
- .git 이라는 폴더가 하나 생김
- 여기에 git은 이 저장소에서 변경된 모든 메타데이터와 버전 기록을 남깁니다.
- 또한 기본 구성 파일과 훅등을 설정합니다.

**기본구성**

- .git/config
    - 기본 설정 파일(저장소 정보 및 원격 저장소의 위치 등0
- .git/HEAD
    - 현재 Git에서 어느지점에 위치해 있는지를 알려주는 포인터
- .git/hooks
    - pre-commit, push등 Git 라이프사이클에 따라 특정시점에 동작하는 스크립트등의 정보
- .git/objects
    - 저장소를 구성하는 개체들. Tree, Commit, Blob등 폴더로 이루어져 있음
- .git/refs
    - 브랜치, 태그, 원격 레퍼런스 등 참조에 대한 내용이 들어 있음.

### 스테이징

- Git에서의 스테이징은 저장소에 커밋될 변경 사항을 준비하는 프로세스를 의미
- Git 저장소의 파일을 변경할 때 해당 변경 사항은 Git에 의해 자동으로 추적은 하지만, 자동으로 반영하지는 않음.
- 수정된 파일을 준비 영역에 추가하여 변경 사항 추적을 시작하도록 Git에 명시적으로 지시해야 합니다.
- 스테이징을 하기 위해 어떤 파일을 추적할 것인지 선택해야 합니다.

### Commit

- 우리는 로컬 시스템에서 파일을 수정, 생성, 삭제하고 원격 저장소로 업로드
- 이때 원격저장소에 반영할 파일들을 선별하는 것이 Commit
- Git commit은 로컬 저장소에 변경 사항을 저장하는 데 사용
- Git 저장소의 파일을 변경할 때 해당 변경 사항은 자동으로 저장되지 않음
- Git에게 새 커밋을 생성하여 변경 사항을 저장하도록 명시적으로 지시
- Git commit 명령은 준비 영역의 변경 사항을 스냅샷으로 생성
- .git 폴더에 저장소의 새 리비전으로 저장
- -m 옵션을 사용하여 변경 내용을 설명하는 메세지 추가 가능

```
$ git commit -m "새로운 기능"
$ git commit -m "[hotfix] user model column changes"
```

### Push

- 원격 저장소에 업로드하여 다른 사용자와 커밋을 공유하는데 사용
- 로컬로 변경 내용을 커밋한 후 git 푸시를 사용하여 변경 내용을 Github, GitLab 또는 Bitbucket과 같은 원격 저장소로 보낼 수 있습니다.
- 원격 저장소 지정하기(git remote add <name> <url>

### Upstream

- Git에서 업스트림은 원격 저장소와 로컬 브랜치가 추적하는 브랜치를 의미
- 기본적으로 orgin,master 브랜치를 추적함
- 이 것을 변경함으로써, 로컬의 변경점과 적용되는 부분을 컨트롤할 수 있음.

## Branch란

- 나무가지
- 큰 줄기에 영향을 주지 않고 가지에서만 작업할 수 있음

### Git에서 브랜치란

- Git에서 브랜치는 저장소의 기록에서 특정 커밋에 대한 포인터
- 각 브랜치는 자체 커밋 및 변경 세트를 가질  수 있다
- 브랜치를 사용하여 저장소의 메인 분기에 영향을 미치지 않고 여러 기능이나 버그 수정을 동시에 수행할 수 있다

## Pull Request

- 당기기 요청
- Push 했으니, Pull
- PR은 저장소에 대한 변경 사항을 제안하고 다른 개발자와 협업하는 방법
- PR은 일반적으로 소프트웨어 개발에서 코드 변경을 제안하고 검토하며 저장소의 브랜치를 병합하는데 사용

### PR만들기

- 새로운 브랜치를 만들고 코드를 수정함
- 원격 저장소에도 해당 브랜치를 Push

### PR 리뷰

- 함께 작업하는 작업자가 해당 PR을 리뷰함
- 문제가 될만 한 부분이 있는지를 체크

### PR merge

- Branch를 새로 만드는 것은 새로운 분기가 생기는 것이니 PR Merge를 통해 다시 병합한다.
- 병합 후 더 이상 필요없는 브랜치는 삭제 할 수 있다.

### PR Close

- 문제가 있거나, 중복된 경우,  또는 더 이상 필요없는 경우 PR을 닫을 수 있다.
- PR을 열어둔 상태에서 기존 Branch에 Commit하면 PR에도 모두 반영된다.

## Draft PR

- Draft PR은 git built-in 기능이 아님
- 아직 리뷰를 받을 상태가 아니라는 것을 알림
- 하지만, 내 작업을 Broadcasting할 수 있음
- 공동 작업자에게 내가 무엇을 하고 있는지 보여줄 수 있음
- 규모가 큰 작업인 경우 Draft PR을 이용하여, 변경점을 지속적으로 공유

## Stash

- 수정, 삭제, 변경 했지만, 아직 Commit 하지 않은 변경점을 임시로 저장할 수 있는 커맨드
- 다른 브랜치에 작업해야 했지만, 실수로 현재 브랜치에 작업한 경우 등
- 파일 수정 내용이 많은데, 디버깅이 힘든경우 등 여러 상황에서 사용.
- Stash를 하는 순간 현재 수정본은 전부 저장되면서 마지막 Commit 사앹로 코드는 복원됨

## Reset

- 잘 사용하지 않지만, 사용한다면 이미 어떤 문제가 생겼다는 증거
- git reset은 Repository의 변경 사항을 실행 취소할 수 있는 명령어
- 현재 브랜치의 포인터를 이전 커밋으로 이동하는데 사용함

### Reset 종류

- git reset : 스테이징 해놓은 변경점을 다시 스테이징 되지 않은 상태로 변경합니다. 어떤 커밋에도 영향을 주지 않습니다.
- git reset —soft : 현재 스테이징된 모든 변경점을 unstage 하고 이전 커밋으로 돌아갑니다. 어떤 커밋에도 영향을 주지 않습니다.
- git reset —hard : 이명령은 현재 스테이징된 모든 변경점을 unstage하고 이전 커밋으로 돌아가며, 돌아가는 커밋 이후에 생긴 변경점들을 삭제하면서 돌아갑니다.

## Git diff

- git diff는 작업공간, Stage 된 변경점, 또는 커밋간의 코드 차이를 확이할 수 있는 명령어 입니다.

## Git revert

- git revert는 특정 커밋에서 변경한 내용을 실행 취소할 수 있는 Git 명령어
- 커밋을 폐기하는 git reset(—hard)과 달리 git revert는 원래 커밋에서 변경한 내용을 취소하는 새로운 커밋(Revert Commit)을 생성한다.

## Cherry-pick

- 가지 전체가 아닌 열매만 따는 행위에서 유래됨
- 특정 커밋을 선택하여 다른 브랜치에 적용하는 방식
- 전체 브랜치를 병합하는 대신 선택적으로 merge 할 수 있음

## Github Template

- 어떤 회사를 가도 볼 수 있는 Template
    - 대부분 몇개 안되는 프레임워크를 사용함
    - DB Connection 파트를 포함해 대부분 초기 세팅은 거의 동일함
    - 보일러플레이를 Repository를 넘어서 세팅 가능

## Github Release Tag

- Tag는 변경할 수 없음
- Commit을 사람이 읽을 수 있는 버저닝으로 변경
    - 사람이 읽을 수 있기 때문에 커뮤니케이션에 도움을 준다.
- Release끼리 비교할 수 있음.
- Release Tag으로 릴리즈 사이클을 트래킹 할 수 있음

## Github Branch Protection

- 많은 사람이 함꼐 작업하는 브랜치일수록 필수
    - PR의무화
    - Test Code 작동 및 테스트 커버리지 유지 의무화
    - Conflict 설명 의무화
    - 선형 히스토리 의무화
    - Review 의무화 등

## Github Actions

- Github이 제공하는 빌드, 테스트, 배포 자동화 도구
- 누군가 코드를 Push할 경우 동작함
- 이런 자동화 규칙의 집합이라고 생각하면 된다.
- 비용이 청구됨
